# 计算高可用
说完存储高可用，该计算高可用了，一般在我来看，相对存储高可用计算高可用要简单一些  
想想看，不看本节课之前，自己理解的计算高可用如何实现?    
> 负载均衡。通过冗余的方式，让多个机器处理相同的事情，即使有的机器挂了，也不影响啥  
> 没有了，一个负载均衡就完了吧

还有吗？还有要考虑的点吗？

## 如何设计计算高可用架构
计算高可用架构的设计复杂度主要体现在**任务管理方面**，即当任务在某台服务器上执行失败后，
如何将任务重新分配到新的服务器进行执行。  

考虑的点:  
- 哪些实例可以执行任务
  - 一种就是负载均衡，大家一样
  - 另一种就是不同的机器执行不同的任务，比如主机执行写任务，其他机器执行读操作(zookeeper leader 才有写操作请求)
- 任务如何重新执行
  - 一种就是失败不管。只管新任务
  - 第二种是设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。
  
**其实计算高可用主要关注的点在于设计这个任务管理，他负责如何分配任务，以及失败咋整的问题**

## 实例，现存的如何做这些事情的架构
主备(温备，冷备)，主从什么的就不说了，没啥讨论的

### 对称集群
对称集群其实就是负载均衡  
负载均衡的策略？
- 随机
- 轮询
- hash 这种方式可以找到任务下到了哪个机器
- 复杂的还有，根据节点能力进行分配任务的

#### 设计考虑的点
- 负载均衡策略选择
  > 根据自己的业务来，一般来说轮询或者hash可以搞定
- 检测节点状态
  > 状态要检测好，挂掉的节点不要分配任务给它。新加的节点要分配任务给它。 Eureka 的服务发现与注册功能  
  > 另外要考虑的，什么情况下算节点挂掉？ 反应慢还是没反应，要根据业务设计。spring cloud 的设计方案直接拿来用可以

### 非对称集群
不同的节点搞不同的事情，分master slave了  

咱们看下设计流程吧直接:  
- 集群会通过某种方式来区分不同服务器的角色。例如，通过 ZAB 算法选举，或者简单地取当前存活服务器中节点 ID 最小的服务器作为 Master 服务器。
- 任务分配器将不同任务发送给不同服务器。
- 当指定类型的服务器故障时，需要重新分配角色。例如，Master 服务器故障后，需要将剩余的 Slave 服务器中的一个重新指定为 Master 服务器；如果是 Slave 服务器故障，则并不需要重新分配角色，只需要将故障服务器从集群剔除即可。

所以相对于对称集群，非对称的复杂点在:  
- 分配策略
- leader的选举

#### Zookeeper 怎么做的
- 任务分配器:  
  ZooKeeper 中不存在独立的任务分配器节点，每个 Server 都是任务分配器，Follower 收到请求后会进行判断，
  如果是写请求就转发给 Leader，如果是读请求就自己处理。
- 角色指定:  
  ZooKeeper 通过 ZAB 算法来选举 Leader，当 Leader 故障后，所有的 Follower 节点会暂停读写操作，开始进行选举，直到新的 Leader 选举出来后才继续对 Client 提供服务。  CP 啊



所以回到最开始的问题，高可用计算类的，除了负载均衡还要考虑一个任务分配器的事情以及leader选举的问题(如果非对称的话)
